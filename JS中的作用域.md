# JS中的作用域
在学习一项东西时，问自己是什么、为什么、怎么样。

## 编译过程

1. 词法分析（Lexing）
将`var a = 2`分解成var、 a、 =、 2
1. 语法分析（Parsing）
这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）
1. 代码生成
将AST转换成可执行代码。



## 作用域

> 作用域是根据标识符名称查找变量的一套规则。

例如如下代码运行时，foo函数该如何找到其中变量a呢？

```javascript
var a = 1
function foo () {
  console.log(a)
}
foo()
```

在上面的代码中，根据标识符名称a来查找变量的规则就是作用域。

具体查找规则如下：

1. 首先在当前作用域（在这里是foo函数作用域）进行查找。
2. 如果没有找到则向上一层级作用域查找，如果找到则返回并且停止查找。
3. 最终查找到全局作用域，如果没有查找到则引起ReferenceError。

### 变量的赋值操作

在JS中的作用域是词法作用域。



## 词法作用域

> 词法作用域是在编译过程的词法分析阶段就确定好的作用域，也就是定义在词法阶段的作用域。当你写好代码时，作用域就已经确定了。而动态作用域是在代码实际执行时才会确定的规则。

JS所遵循的作用域就是词法作用域。与之相对的动态作用域。无论函数在哪里被调用，也无论它如何被调用，他的词法作用域都只由函数被声明时所处的位置决定。

在JS中，构建出的词法作用域共有两种，一是函数作用域，二是块级作用域。



## 函数作用域

每声明一个函数就会创建一个函数作用域。

例如第一节中的代码，便有一个全局作用域和foo函数的函数作用域。

函数作用域多用来



## 块级作用域

ES6中引入了新的let和const关键字，是区别于var之外的变量声明方式，可以将变量绑定在所在的作用域中，从而实现块级作用域。

例如，如下代码。

```javascript
if (true) {
  let a = 1
}

if (true) {
  var b = 1
}

console.log(a) // ReferenceError: Can't find variable: a
console.log(b) // 1
```

可见在使用let关键字声明变量a时创建了{…}之间的块级作用域，使得全局w作用域无法访问到a的值。

块级作用域还有一个典型的例子，便是在循环中绑定函数。

```javascript
for (var i = 0; i < 5; i++) {
  setTimeout(function callback () {
    console.log(i)    
  }, i*1000)
}
```

如果不去执行，思考上述代码你觉得会输出什么呢？很遗憾，输出的并不是‘0,1,2,3,4’。而是5个‘5’。这是因为在迭代五次的五个callback函数中去查找变量i时，它们查找到的都是函数作用域外的同一作用域下的同一变量i。而这时i已经完成循环并且值为5。所以五个不同作用域的callback函数才会输出的都是5。而解决这个问题的方法也很简单，那就是在for循环中创建5个作用域来存储i的值。

在let关键字出现之前，解决这个问题的办法是使用闭包创建函数作用域。

```javascript
for (var i = 0; i < 5; i++) {
  (function (i) {
    setTimeout(function callback () {
      console.log(i)    
    }, i*1000)
  })(i)
}
```

每次迭代都会将i传进一个函数作用域，从而保存住本次迭代下i的值。所以会输出‘0,1,2,3,4’。

而使用let关键字，可以更好地解决这个问题。

```javascript
for (let i = 0; i < 5; i++) {
  setTimeout(function callback () {
    console.log(i)    
  }, i*1000)
}
```

看！for循环头部的let声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。

const和let的唯一区别就是const定义的是一个无法改变的常量，并且在初始化时必须为其赋值，否则会引发

> Uncaught SyntaxError: Missing initializer in const declaration

如果尝试修改用const声明的值则会引发

> Uncaught TypeError: Assignment to constant variable。



